<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >The CUFP Workshop 2009</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><link rel="stylesheet" href="nominolo.css" type="text/css" media="all" />
</head
  ><body
  ><h1 class="title"
    >The CUFP Workshop 2009</h1
    ><div id="TOC"
    ><ul
      ><li
	><a href="#opening"
	  >Opening</a
	  ></li
	><li
	><a href="#keynote-real-world-haskell"
	  >Keynote: Real World Haskell</a
	  ></li
	><li
	><a href="#scala-at-edf-trading"
	  >Scala at EDF Trading</a
	  ></li
	><li
	><a href="#erlang-at-hoverin"
	  >Erlang at hover.in</a
	  ></li
	><li
	><a href="#the-big-board"
	  >The Big Board</a
	  ></li
	><li
	><a href="#the-first-substantial-line-of-business-applications-in-f"
	  >The First Substantial Line of Business Applications in F#</a
	  ></li
	><li
	><a href="#functional-programming-at-facebook"
	  >Functional Programming at Facebook</a
	  ></li
	><li
	><a href="#fmd---functional-development-in-excel"
	  >FMD - Functional development in Excel</a
	  ></li
	><li
	><a href="#building-the-user-programmable-internet-with-erlang"
	  >Building the User Programmable Internet with Erlang</a
	  ></li
	><li
	><a href="#clear--simple-composing-a-marketplace"
	  >Clear &amp; Simple: Composing a Marketplace</a
	  ></li
	><li
	><a href="#birth-of-the-industrial-haskell-group"
	  >Birth of the Industrial Haskell Group</a
	  ></li
	><li
	><a href="#cufp-discussion"
	  >CUFP Discussion</a
	  ></li
	></ul
      ></div
    ><p
    >Notes taken from the <a href="http://cufp.galois.com/"
      >2009 Commercial Users of Functional Programming</a
      >, Edinburgh Scotland.</p
    ><div id="opening"
    ><h2
      ><a href="#TOC"
	>Opening</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6704601"
	>CUFP Welcome and Overview</a
	></p
      ><ul
      ><li
	>Jim Grundy, <a href="http://www.erlang-consulting.com/"
	  >Francesco Cessarini</a
	  ></li
	></ul
      ><p
      >Growth figures for languages</p
      ><ul
      ><li
	>Good absolute growth in job statistics</li
	><li
	>Good percentage growth.</li
	><li
	>Good improvements in all FP language rankings on TIOBE</li
	><li
	>Lots of books. Good sign.</li
	></ul
      ><hr
       /></div
    ><div id="keynote-real-world-haskell"
    ><h2
      ><a href="#TOC"
	>Keynote: Real World Haskell</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6703480"
	>Real World Haskell</a
	></p
      ><ul
      ><li
	><a href="http://www.serpentine.com/blog/"
	  >Bryan O'Sullivan</a
	  ></li
	></ul
      ><p
      >A call to arms to the functional programming community.</p
      ><p
      >Bryan talks about how <a href="http://book.realworldhaskell.org/"
	>Real World Haskell (the book)</a
	> came to be, and the response that it has received since publication. He will also discuss the opportunities presented, and the challenges faced, by functional languages in open source and in industry.</p
      ><ul
      ><li
	>Got into Haskell and FP at Glasgow in the early 90s.</li
	><li
	>Tight community. Intellectual energy.</li
	><li
	>2005: community was still very introverted.</li
	><li
	>How did you learn Haskell?<ul
	  ><li
	    >from a lecturer?</li
	    ><li
	    >from a book?</li
	    ></ul
	  ></li
	><li
	>Training:<ul
	  ><li
	    >immersion: reading source, reading papers, writing lots of code</li
	    ></ul
	  ></li
	><li
	>No clear training materials - ad hoc, self-directed, unstructured search through web materials</li
	><li
	>Good contibutions: write a book showing how to learn stuff</li
	><li
	>Book got really big.<ul
	  ><li
	    >needed additional authors</li
	    ></ul
	  ></li
	><li
	>Incremental chapters online.<ul
	  ><li
	    >800+ reviewers, very quick</li
	    ><li
	    >7,500 comments on the material</li
	    ></ul
	  ></li
	><li
	><em
	  >Time to write a book!</em
	  ><br
	   /></li
	><li
	>Long term attitude, &quot;let the moutain come to Mohammed&quot;, need to invert that.</li
	><li
	>You don't need to write a 700 page book.</li
	><li
	>Good ideas will build up a community<ul
	  ><li
	    >tenacity</li
	    ><li
	    >an idea</li
	    ><li
	    >explanatory skill</li
	    ><li
	    >pain</li
	    ></ul
	  ></li
	><li
	>Blog: practice explaining.</li
	><li
	>Ideas for the next Haskell book:<ul
	  ><li
	    >Writing and Tuning Fast Haskell Code</li
	    ><li
	    >Parallel Haskell in 24 Hours</li
	    ><li
	    >High Assurance Haskell</li
	    ><li
	    >Modelling in Haskell</li
	    ><li
	    >Abstract Algebra for Categorical Dummies (see the haskell articles on the math reddit)</li
	    ><li
	    >Building complex/large functional applications Structuring/architectures<ul
	      ><li
		>Grow your own monads in the basement</li
		><li
		>Concurrent network programming</li
		><li
		>Functional pearls and design patterns</li
		><li
		>Secrets of the QuickCheck wizards</li
		></ul
	      ></li
	    ><li
	    >Concepts &quot;Typeclasses with extra C++ special sauce&quot; -Who is the audience?<ul
	      ><li
		>Day to day programmers</li
		><li
		>Environment and communities with archaic technology</li
		><li
		>&quot;Here are the things you need to know in order to be successful&quot;</li
		></ul
	      ></li
	    ><li
	    >Talk to other communities</li
	    ></ul
	  ></li
	><li
	>Great anecdote about &quot;POSIWID&quot; / CyberSyn<ul
	  ><li
	    >Didn't know it was going to be impossible, so they just went and did it</li
	    ><li
	    >&quot;The purpose of a system is what it does&quot;<ul
	      ><li
		>Don't try to understand a system from what its designers say it does</li
		><li
		>Observe what it does</li
		></ul
	      ></li
	    ></ul
	  ></li
	><li
	>So what does functional programming actually do? -<br
	   /></li
	><li
	>We don't have to be rockstars...<ul
	  ><li
	    >Hero worship ruined other communities</li
	    ></ul
	  ></li
	><li
	>We don't need to be gurus</li
	><li
	>Grow the community, put some spine to our claims - Write a book - Give a talk - Write a blog post - Teach</li
	><li
	>Keep a welcoming smart community, be nice.</li
	></ul
      ><p
      >Questions:</p
      ><ul
      ><li
	>Get someone really famous at CUFP?</li
	><li
	>User groups/ training - Brings in curious outsiders</li
	><li
	>Creative commons license for text.<br
	   /></li
	><li
	>Effect of the book - fame - distribution of knowledge - growth in community</li
	><li
	>Killer apps / where is the rails for Haskell?</li
	><li
	>What is FP? A community of knowledge. - growth and tension with ideas. - maintain the community / positive and constructive</li
	><li
	>We've failed at avoiding success</li
	><li
	>How important do you think the uptake of FP on .NET and JVM will be?</li
	><li
	>F# et al as a gateway drug<br
	   /></li
	><li
	>As the community grows there will be fragmentation - parts that don't need growth.</li
	><li
	>What's the GHC developers view on the widening use of Haskell? - Demand pull from users is a great research incentive - Will need more and more help with maintainance / bugs - Need the Industrial Haskell Group for this kind of thing</li
	></ul
      ><hr
       /></div
    ><div id="scala-at-edf-trading"
    ><h2
      ><a href="#TOC"
	>Scala at EDF Trading</a
	></h2
      ><p
      >Implementing a Domain-Specific Language for Derivative Pricing with Scala</p
      ><p
      ><a href="http://www.vimeo.com/6702641"
	>Scala at EDF Trading</a
	></p
      ><ul
      ><li
	>Speaker: Lee Momtahan, EDF Trading</li
	></ul
      ><p
      >In this talk I shall explain how Scala has been used at EDF Trading. We have used Scala to implement Diesel: a domain-specific language used within our in-house system for pricing/risk-managing/hedging commodity derivatives. Diesel can represent commodity derivatives naturally and can then be executed to perform a Monte Carlo simulation. Compared to writing derivative-specific Monte Carlo simulations in a general-purpose computer language, the per-derivative development time has been reduced from weeks to hours.</p
      ><p
      >We have been using Scala within a large code base of 300k lines of Java on a on a business-critical, production system, where performance requirements are key. Based on this experience, the second part of the talk will discuss the suitability of Scala for use within this context, comparing the risks of using a niche language against its productivity benefits.</p
      ><ul
      ><li
	>Used Scala to develop a derivatives pricing DSL. EDFT. (not embedded, language fully parsed via Scala)</li
	><li
	>300k line of Java code base for trade/hedge/risk-management</li
	><li
	>Production Java system</li
	><li
	>Using Scala for last 12 months - most new classes in the system are developed in Scala</li
	><li
	>Requirements: - needed to integrate with Java - Concisely express mathematical concepts - Needed access to libraries - Needed to run on JVM</li
	></ul
      ><p
      >DIESEL: EDFT's domain-specific language for pricing custom derivatives Very concise notation that implements textual descriptions of how to do the pricing Quite concise description of the AST. clear language design Elegant semantics</p
      ><p
      >Illustrates interesting use of mixed OO/Functional style, supports macros,</p
      ><ul
      ><li
	>DSLs are great when you want to span a space of concerns</li
	><li
	>2k lines of Scala</li
	><li
	>Uses combinator parsing</li
	><li
	>Reuses e.g. CERNs Colt library for fast vector arithmetic</li
	><li
	>Results: reduced the turn around time of analytics</li
	><li
	>Scala removes boilerplate. 2-3x less code than in Java.</li
	><li
	>Uses mixture of imperative and functional style</li
	><li
	>Practicalities: * IDE support is not at Java's level, but is improving * Eclipse, and IntelliJ/IDEA * Java debugger requires care</li
	><li
	>Compiler performance is good, but could be improved</li
	><li
	>Found a small number of bugs in compiler and libraries</li
	><li
	>Developers took to Scala quickly</li
	><li
	>'ecosystem' favors C++ or Java (handling inertia is hard)</li
	><li
	>Gentle learning curve.</li
	><li
	>More to it than just getting the language right. - Outreach? - See what effect time has</li
	><li
	>Risks have been outweighed by productivity benefits</li
	></ul
      ><p
      >Question:</p
      ><ul
      ><li
	>Why not use an embedded DSL from the start? - Parsing isn't too much work - Need runtime reflection ideas</li
	><li
	>Why did you leave Java? - Scala is better than Java, even for imperative code</li
	><li
	>Was it the functional part, or the Java part that interested you - No. High level notation. Functional aspects.</li
	></ul
      ><hr
       /></div
    ><div id="erlang-at-hoverin"
    ><h2
      ><a href="#TOC"
	>Erlang at hover.in</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6702023"
	>Erlang at hover.in</a
	></p
      ><ul
      ><li
	>Bhasker Kode, hover.in,</li
	></ul
      ><p
      >I'm Co-Founder &amp; CTO at 'hover.in', the in-text content &amp; ad delivery platform that let's blogs and website publishers to push client-side events to the cloud. The start-up predominantly runs off the LYME stack ( Linux / Yaws / Mnesia / Erlang ) .</p
      ><p
      >From our experiences at 'hover.in' I'd like to discuss why we chose using Erlang and got about using it as our bridge across our multi-node cluster. In particular the architectural decisions that went into making our distributed python crawler back-end running off Mnesia with its sharing &amp; fragmentation strategies for tables that span several millions of rows, load-balancing to our 3-node Yaws web servers, tweaks to solve file descriptor &amp; efficiency bottlenecks, experiments in DHT's, our cache worker implementations, our messaging queues, cron's &amp; trade offs in dispatching jobs also throw light on design choices that can fit in distributed and heterogeneous environments. We have also recently built our own in-memory cache workers, persistent stats &amp; logging system, and in the process of now building our own A/B testing framework, that we'd love to talk about.</p
      ><p
      >After an initial quite 1 1/2 years of Erlang in production, we've just launched our developer blog which might give a closer insight of our work:</p
      ><ul
      ><li
	>notes on our multi-core computing &amp; back-end experiences</li
	><li
	>notes on using a Erlang based load-testing tool (Tsung)</li
	><li
	>my talk on 'Erlang at hover.in' at devCamp Bangalore (with one slide listing all the modules written as well)</li
	><li
	><p
	  >a more product-oriented interview</p
	  ></li
	><li
	>Building a distributed system.</li
	><li
	>Use case: millions of pages, bursty traffic, need to build an index and show related content</li
	><li
	>Requires parallelization<ul
	  ><li
	    >Need to do traffic shaping</li
	    ></ul
	  ></li
	><li
	>Needed to take care to avoid sequential code<br
	   /></li
	><li
	>Priortize work based on popularity</li
	><li
	>Described how to split up tasks to get maximum performance from limited hardware</li
	><li
	>Load balancing was a concern</li
	><li
	>Provided details on replication and storage</li
	><li
	>In the recession, fixed length buffers are making a come back. - Twitter,facebook - Better for real time results</li
	><li
	>In-memory vs disk - 4-32G of ram - versus adding 100k nodes a quarter - in-memory caching</li
	><li
	>Erlang good for distributed, in-memory storage<br
	   /></li
	><li
	>7 rules for in-memory capacity planning - shard thy data - do flow control of traffic - some data is less important - time mulitplied by ram utilization == constant - interleave in-memory and disk access - measure performance</li
	><li
	>robustness under bursty load. - lots of message passing, communication of events to handle different scenarios, and adapt to change</li
	><li
	>cross language communication formats are key - uses rabbitMQ for python &lt;-&gt; erlang communication!</li
	><li
	>interesting analogies from biology and neuroscience for designing adaptive, scalable information structures</li
	><li
	>Infrastructure: - uses LYME - python crawler - tokyo-cabinet storage - inverted indexes in erlang mnesia - priority queues for determing work based on popularity - headless firefox for page screenshots - 1 million hovers/month</li
	><li
	><p
	  >business: ad for what happens when you hover over a word on your blog &quot;in-text broadcasting&quot;</p
	  ></li
	></ul
      ><p
      >Questions:</p
      ><ul
      ><li
	>How do you find employees to do Erlang in India? - &quot;We didn't even tell them it was difficult&quot; - All our developers are right out of college, so they expect to learn - Have one Haskell guy.</li
	></ul
      ><hr
       /></div
    ><div id="the-big-board"
    ><h2
      ><a href="#TOC"
	>The Big Board</a
	></h2
      ><p
      >Teleconferencing over High-res Maps with Haskell</p
      ><p
      ><a href="http://www.vimeo.com/6701254"
	>The Big Board</a
	></p
      ><ul
      ><li
	>Jefferson Heard, Renaissance Computing Institute</li
	></ul
      ><p
      >A public emergency is the ultimate example of multitasking and collaboration over a wide area. Crowd control, first aid, fire, police, and search and rescue teams all have to provide a timely and coordinated response to save lives and property. This requires situational awareness, meaning that emergency managers know what and where their resources are on the ground, and what the ground's features are. Managers who direct emergency operations centers have few technological tools to help them with these complicated, critical tasks. They are, in fact, still largely paper based.</p
      ><p
      >The Big Board aids in filling this technological gap by providing aerial photography, facility for dynamic, geo-referenced content creation, and a mechanism for simulcasting the content to everyone participating in the management of an emergency. The goal is that it should give emergency managers a reliable and flexible way to coordinate on their most natural medium (maps), be as easy to use as pen and paper, quick to train a new user on, and able to run in many environments, some quite technologically out of date.</p
      ><p
      >In The Big Board, users open a map, join a virtual conference room, and then can collaboratively mark up the map with paths, polygons, and placemarks and add content behind these using a wiki that is generated as part of every conference room. As they mark up the map, their annotations are simulcasted to everyone else in the same conference room. Additionally, web-services serving geo-referenced content can be integrated onto the map to overlay things such as real-time vehicle location and sensor data.</p
      ><p
      >This application has been written from the ground up in Haskell, with a PostGIS backend. Haskell was chosen for its laziness, reliability of applications written in it, rapid development, multicore scalability, and native compilation. In this presentation I will describe:</p
      ><ul
      ><li
	>The Big Board, who's using it, and where we're going with it.</li
	><li
	>The requirements of it, and how Haskell fulfills these requirements better than the alternatives.</li
	><li
	>A high level overview of the application's structure.</li
	><li
	>The challenges and advantages of functional design in such a large application.</li
	><li
	>How the design led naturally to two reusable, publicly available libraries now in Hackage: Buster (FRP for application orchestration) and Hieroglyph (for functional 2D vector-graphics).</li
	></ul
      ><p
      >I will also give a demonstration of the application running, showing how it can be used to coordinate a disaster response.</p
      ><ul
      ><li
	>Big Board in wide use</li
	><li
	>Disaster response in Haskell - requirements: collaborate on geographical lines - no political or state boundaries</li
	><li
	>Groups have not necessarily ever worked together</li
	><li
	>Shared workspace is a map - replacement for pen/paper on maps + couriers</li
	><li
	>Lack of information in real time</li
	><li
	>Require distributed development</li
	><li
	>Open source is better for the counties, with budget constraints</li
	><li
	>Training burden should be light (30 mins to an hour)</li
	><li
	>Teleconferencing on maps - realtime content generation - photography and vector layers - 100% Haskell - gtk2hs, http, parsec, hieroglyph/buster for vis. - python on server side due to very old CentOS (GHC won't build)</li
	><li
	>Use graphical FRP. (buster)</li
	><li
	>Why Haskell? - Haskell code goes onto toughbooks in the field. Old hardware This determines many of the requirements - Good memory and speed, for clients. They're running on old toughbooks - Rapid development - Fast networking - Lots of code reuse - Reliability</li
	><li
	>FP-based visualization - &quot;pretty&quot;-like 2D rendering of data via a type class</li
	><li
	>Entire system is modelled as behaviours and events.</li
	><li
	>Why write a new FRP library? - needed true concurrency - broadcast model - dynamic - central event space and broadcasting events</li
	><li
	>5k lines of code. Three libraries produced. - Hieroglyph: visualization - Buster, orchestration - A GIS library</li
	><li
	>Protyped in Python, but abandoned due to reliability and performance problems.</li
	><li
	>Results from Haskell - rapid development (full thing built in 2 months) - good reuse and refactoring - high performance compared to competitor high-level languages - active and responsive community - &quot;Every question I asked was answered&quot; - tuned to get required performance</li
	><li
	>Live networking, 60 fps map updates, 2-3 second sync across entire system</li
	><li
	>Use type system to concentrate on semantics</li
	><li
	>Pure code helps reuse, clearer code - separation of IO and data - concise code was good for explaining / teaching (good for advocacy)</li
	><li
	>Disadvantages (smallish): - No nearby Haskell group - Little overlap with graphics community (but good libraries) - Pretty much only visualization person in Haskell - Small commercial community</li
	></ul
      ><p
      >Questions:</p
      ><ul
      ><li
	>Dealing with unreliable network? - exception handling - lazy IO over HTTP - stable - uses laziness to download minimal content</li
	><li
	>Dealing with a small footprint? - Took advantage of fusion - Wrote carefully</li
	></ul
      ><hr
       /></div
    ><div id="the-first-substantial-line-of-business-applications-in-f"
    ><h2
      ><a href="#TOC"
	>The First Substantial Line of Business Applications in F#</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6700412"
	>The First Substantial Line of Business Application in F#</a
	></p
      ><ul
      ><li
	>Alex Peake, TFC, Adam Granicz, Intellifactory</li
	></ul
      ><p
      >We have developed MarketingPlatform(tm) a marketing automation solution delivered as Software as a Service with F# as the primary language. MarketingPlatform(tm) is a solution for marketers in direct marketing and in channel marketing who would like to gain a timely and deep understanding of what is working and what is not working in their marketing campaigns. Marketers are than facilitated in the execution and delivery of campaigns, using this insight to create relevant communications to each individual. It is divided into four tightly integrated campaign management steps of Measure, Analyze, Design and Execute.</p
      ><p
      >Measure: How well are my campaigns working? Are they meeting the goals?</p
      ><p
      >Analyze: Why are the campaigns exceeding goals, or falling short of goals? What sub-segments are worthy of further communications with?</p
      ><p
      >Design: Create communications that are relevant to each individual, driven by the data and insight gained from measurement and analysis.</p
      ><p
      >Execute: Deliver the communications through the most appropriate channels, including email, print and mail, texting and purls.</p
      ><ul
      ><li
	>Why did TFC management choose F#?</li
	></ul
      ><p
      >F# is a functional language with first class functions and composability, a pattern matching language and strongly typed. At the same time it as a .NET CLR language, fully interoperable with the vast libraries, and fully capable of OOP. So we believed that we would get the best of both worlds &#8212; a modern productive language and a full set of libraries to build on. The product is in the market and selling well, so we were rewarded by our decisions. Where was F# applied within the application, and where not?</p
      ><p
      >Most of the business logic was implemented in F#, as was most of the data handling. C# was retained for building the ASP.NET user interface, just because the F# tool support is not there yet.</p
      ><ul
      ><li
	>What were the development benefits?</li
	></ul
      ><p
      >The application was developed in less time with significantly less code &#8212; probably a quarter. The code is more readable and easier to adapt as new market requirements come in.</p
      ><ul
      ><li
	>What were the business benefits?</li
	></ul
      ><p
      >We were able to get to market much sooner with more feature, and the overall cost of the development was significantly lower.</p
      ><ul
      ><li
	><p
	  >Conclusion: F# is an excellent language for line of business applications. It somewhat shortens the development cycle and greatly shortens the enhancement cycle.</p
	  ></li
	><li
	>IntelliFactory, developed &quot;MarketingPlatform&quot; in F# for TFC<ul
	  ><li
	    >Marketing software suite</li
	    ><li
	    >.NET / Windows based</li
	    ><li
	    >IntelliFactory does F# development, training, DSLs, web apps</li
	    ><li
	    >Tries to bridge academia and industry</li
	    ></ul
	  ></li
	><li
	>Why did they choose F#?<ul
	  ><li
	    >More functionality in less code</li
	    ><li
	    >Productivity over C#</li
	    ><li
	    >Newly embraced distribution and parallelism</li
	    ><li
	    >Good numerics support</li
	    ></ul
	  ></li
	><li
	>Visual Studio support for F# will increase jobs for F#</li
	><li
	>MarketingPlatform manages content, creation, groups, assets for marketing</li
	><li
	>Web execution - payment, printing, loading, rendering</li
	><li
	>Issues we faced when designing the system - Speeding up data access (large amounts of data)</li
	><li
	>F# at work: - memoization - active patterns - lazy sequences (reduces memory use, laziness over streams) - domain specific languages</li
	><li
	>What not to say: - &quot;FP is a whole different way to think about problems and requires a new foundation to build apps&quot;</li
	><li
	>What to say: - &quot;FP allows to take what you have and extend it much quicker and better than without&quot;</li
	><li
	>ASP.NET is not very functional<br
	   /></li
	><li
	>Use F# formlets DSL for web development.</li
	><li
	><p
	  >Use laziness for SQL access.</p
	  ></li
	></ul
      ><p
      >Questions:</p
      ><ul
      ><li
	>Patterns when combining FP and OO in the same code?<ul
	  ><li
	    >Objects are a key part of FP in F#. But it doesn't disturb much.</li
	    ><li
	    >OO method invocation versus function calls.</li
	    ></ul
	  ></li
	><li
	>nullPointer exceptions? What happens when you call in to .NET?</li
	><li
	>How problematic is that?<ul
	  ><li
	    >When you access libraries, null is always a possibility</li
	    ><li
	    >Use pattern matching.</li
	    ></ul
	  ></li
	></ul
      ><hr
       /></div
    ><div id="functional-programming-at-facebook"
    ><h2
      ><a href="#TOC"
	>Functional Programming at Facebook</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6699769"
	>Functional Programming at Facebook</a
	></p
      ><ul
      ><li
	>Christopher Piro and Eugene Letuchy, Facebook</li
	></ul
      ><p
      >We use Erlang, ML, and Haskell for a few small projects but (as I'm sure you guessed) we'd like to focus on the lessons we've learned using Erlang for building Facebook Chat. The channel servers are at the heart of our Chat infrastructure; they receive messages from our web servers and queue them for HTTP delivery. Presence information, the knowledge of who is currently using Chat, is aggregated and shipped to a separate service. The service has been operational since our launch about a year ago and we continue to develop and improve it frequently. We're also developing an XMPP interface to Facebook Chat based on the ejabberd project. A lot of functionality has been added to interact with the many moving parts of our infrastructure.</p
      ><p
      >Erlang has been the right tool for the job. It's well-known that Erlang is a good choice for communications applications and real-time chat in particular, and we'd like to mention that Erlang's strong support for concurrency, distribution, hot code loading, and online debugging have been indispensable, and that it's those same weaknesses that lead us away from C++ when first designing the service. However, we'd like to focus on the factors inside and outside Facebook that enabled us to choose Erlang in the first place. Most importantly, we needed good support for language-independent RPC. Fortunately we rely heavily on Thrift for all our services. Both the channel and Jabber servers need to speak to programs written in PHP and C++, and having infrastructure and engineers comfortable debugging it already in place when we began was invaluable. Our service management tools as well are language-independent; all our services regardless of language are controlled using the same interface. Facebook and the Thrift project are also fortunate to have an active community. The original Thrift binding for Erlang was implemented in-house but substantial portions were reimplemented by outside contributors. As well we've leveraged existing open source products including ejabberd and Bob Ippolito's Mochiweb framework.</p
      ><p
      >The other half of our story consists of the barriers presented and risks taken in choosing Erlang. I mentioned above that much of Facebook's infrastructure is language-agnostic, but our build and deploy systems unfortunately are not. Many of our internal tools weren't written with Erlang or (in particular) hot code reloading in mind, so we needed to write many one-offs to support all the runtime goodness that Erlang affords us. Facebook runs many services, most of which are in C++, Python, or Java, and only two in Erlang, so in some respects we've needed to work harder to integrate. We at Facebook also tend to work in large codebases and share the responsibility of bug fixing. Unfortunately, our Erlang projects live outside of our main repository, and the extra learning necessary to develop or just fix bugs in Erlang tends to keep us isolated from the pool of talent in our department. Unsurprisingly, the job of fixing Chat bugs falls to one of a very small group, whereas bugs in our PHP code have a small army of PHP generalists waiting to squash them. However Erlang has such a steep learning curve only because most undergraduate programs don't stress functional programming, and Facebook in particular doesn't expose most engineers to functional programming, or even information about the strengths and weaknesses of FP versus PHP, C++, and Python. In particular we'd like to touch on the prevalence of object-oriented programming in education and in practice, and the tendency of engineers (even engineers with FP experience) to guide their design by OOP principles even when they don't fit. The recurring theme is &quot;the right tool for the job&quot; &#8212; actor-based, functional, imperative, and object-oriented programming are all valuable tools for modeling particular problems, but the most important lessons in our experience are how to lower the barriers to choosing the right tool, and how to arm engineers with the knowledge they need to make an appropriate choice.</p
      ><ul
      ><li
	>Functional Programming at Facebook</li
	><li
	>Values in engineering - fast iterations - using many different languages - use thrift to ensure language interoperation</li
	><li
	>Erlang at facebook - chat backend/channel servers/ejabberd/AIM</li
	><li
	>Haskell at Facebook - PHP parse transforms in Haskell - Lambdabot (with facebook specific extensions) - textbook: command line interface to facebook API - thrift binding in Haskell</li
	><li
	>Thrift - efficient, cross-language serialization</li
	><li
	>Facebook chat - Real time communication chat - Hackathon in 2007 to get facebook chat - Coded and learned Erlang - Feb 2008 : simulates load on Erlang servers</li
	><li
	>One billion messages a day over the chat. 1G traffic at peak. 100 machines to service the load</li
	><li
	>Erlang strengths - Cheap parallelism and concurrency - modelling concurrent interactions via threads (one per user) - Locality of reference - State is kept locally, easier to reason about a user's session - Distribution - Connected nodes work easily (remote/local servers, handling failure) - Fault isolation - Early chat had a lot of bugs, but wasn't fatal - The bugs didn't wipe out the entire system - Crash reports - Stack traces from crash reports, made easier to reproduce faults thanks to referential transparency - but too much logging can cause memory problems - Hot code swapping - Can upgrade code on the cluster in 20 seconds - Can also rollback code easily - we don't use OTP upgrading yet - Monitoring - Extensions to the supervisor - heart monitors are good - Hibernation - (dramatically shrinks memory usage)</li
	><li
	>Use mutable arrays (cheating) to match a data structure format that C++ uses</li
	><li
	>Problems - Used to not be many english-based resources, small community - it has got a lot better - Universities aren't training up people for FP properly - Not hiring explicitly for FP - Can't reuse much C++ or PHP - Divides up company between imperative / functional engineers - Learning another language in the company counters the &quot;move fast&quot; philosophy.</li
	><li
	>What has worked: - Give evidence for why to use FP - Give tech talks - Used ICFP as excuse to do more FP - Language independence with Thrift. - &quot;Use the right tool for the job&quot;</li
	></ul
      ><p
      >Questions</p
      ><ul
      ><li
	>How do you stop people rewriting the code when you are in the minority? - Not much internal pressure to choose a language, as long as the tools work - Business model means moving fast - write lots of new code.</li
	><li
	>Could your bugs have been caught be a type system? - Static analysis caught some of the bugs. But a type system might also work.</li
	><li
	>Thrift: how did that work? - We wrote bindings in house.</li
	><li
	>Use of Haskell? - Enthusiastic Haskell programmers, but small projects. - LexPass is the right tool for heavy lifting. Syntax transforms on PHP in Haskell - &quot;Haskell generates some of the code Facebook uses&quot;</li
	><li
	>Fail over is important for giving us confidence</li
	></ul
      ><hr
       /></div
    ><div id="fmd---functional-development-in-excel"
    ><h2
      ><a href="#TOC"
	>FMD - Functional development in Excel</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6699275"
	>FMD - Functional development in Excel</a
	></p
      ><ul
      ><li
	>Lee Benfield, Barclays Capital</li
	></ul
      ><p
      >Barclays Capital, like many other investment banks, uses Microsoft Excel as a rapid application development environment for pricing models and other tools. While this may sound bizarre, Excel's flexibility and convenience renders it an immensely useful tool for the Front Office, and our Traders are extremely Excel literate.</p
      ><p
      >Excel combines two programming models</p
      ><ul
      ><li
	>a zeroth order functional language (the spreadsheet)</li
	><li
	>an imperative programming language (Visual Basic for Applications)</li
	></ul
      ><p
      >The functional model allows very rapid development and great transparency, but the limitations of Excel's built-in functions drives developers to use VBA. Soon the spreadsheet dependency graph is lost and the spreadsheet layer is relegated to a GUI on top of tens/hundreds of thousands of lines of VBA. The logic is tightly tied to Excel, and a server-side implementation involves a complete rewrite in another language, which carries both operational risk and developmental cost.</p
      ><p
      >FMD (&#8216;Functional Model Deployment&#8217;) prevents these problems by embedding a functional language cleanly into Excel, effectively extending Excel to be a higher order functional environment. Now complex models can be developed without leaving the pure spreadsheet domain:</p
      ><p
      >Before</p
      ><ol style="list-style-type: decimal;"
      ><li
	>Limited built-in functions need to be extended with add-ins or VBA.</li
	><li
	>Boilerplate code needs to be written to import libraries.</li
	><li
	>Systems need to be rewritten to run outside Excel. (typically ported to C++ / C# back end)</li
	></ol
      ><p
      >After</p
      ><ol style="list-style-type: decimal;"
      ><li
	>Functions can be defined on-the-fly without leaving the pure spreadsheet side.</li
	><li
	>Dynamic and data-driven wrappers make external libraries directly visible.</li
	><li
	>Spreadsheet 'programs' can be exported and run outside of Excel.</li
	></ol
      ><p
      >The business have fully supported this approach, and are enthusiastic about using FMD - as Simon Peyton Jones identified elsewhere, &#8220;Excel is the world's most popular functional language&#8221;. From their point of view, functional programming in Excel is just an extension of what they've been doing for years!</p
      ><ul
      ><li
	>BarCap, quantitative analytics group.</li
	><li
	>Excel is ubiquitous in investment banking</li
	><li
	>Why? - Visualization - Immediacy - Flexibility - Control - traders like control</li
	><li
	>No object support, poor library support</li
	><li
	>VBA as glue between real code and excel - to work around lack of functions, data types etc</li
	><li
	>FMD: a layer between quant code and Excel</li
	><li
	>Adding FP-like macros/DSL to make Excel more convenient.</li
	><li
	>In use by about 250 Excel users now</li
	><li
	>Interpreter for DSL implemented in C++</li
	><li
	>Excel is weak for type correctness</li
	></ul
      ><hr
       /></div
    ><div id="clear--simple-composing-a-marketplace"
    ><h2
      ><a href="#TOC"
	>Clear &amp; Simple: Composing a Marketplace</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6698522"
	>Clear &amp; Simple: Composing a Marketplace</a
	></p
      ><ul
      ><li
	>Marc Wong-VanHaren, Glyde</li
	></ul
      ><p
      >Glyde is a web-based marketplace, with the goal of making buying and selling as easy as possible. We also strive to provide a responsive, error-free experience. These goals represent challenges which functional programming helps mitigate.</p
      ><p
      >First, easy-to-use often means complex-to-build, but FP's high-level abstractions and referential transparency help us to manage this complexity. Second, as we handle people's money, mistakes could be damaging, but the expressiveness of FP give us confidence in our code, and a lack of side effects facilitates testing. Third, a responsive site is a pleasure to use, so we write parallelizable logic, which FP's avoidance of side effects makes feasible.</p
      ><p
      >This talk will describe Glyde's use of JoCaml and Scala and discuss our experiences with these tools.</p
      ><ul
      ><li
	>Building a concurrent web marketplace in JoCaml.</li
	></ul
      ><hr
       /></div
    ><div id="birth-of-the-industrial-haskell-group"
    ><h2
      ><a href="#TOC"
	>Birth of the Industrial Haskell Group</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6697688"
	>Birth of the Industrial Haskell Group</a
	></p
      ><ul
      ><li
	>Duncan Coutts, Well-Typed</li
	></ul
      ><p
      >It has long been thought that commercial users of Haskell could benefit from an organisation to support their needs, and that as a side-effect the wider Haskell community could benefit from the actions of such an organisation. The stronger community would in turn benefit the commercial users, in a positive feedback cycle.</p
      ><p
      >At last year's CUFP, users of several FP languages raised the issue that there was no organisation that they could pay to do the important but boring work of maintaining and improving common infrastructure. Shortly after CUFP, in partnership with major commercial users of Haskell such as Galois and Amgen, we started to set wheels in motion, and in March 2009 we announced the birth of the Industrial Haskell Group (IHG).</p
      ><p
      >The IHG is starting off with a limited set of activities, but already it is having an impact on the state of the Haskell development platform. We expect that as it expands, it will become a significant force driving Haskell forwards.</p
      ><p
      >In this presentation we will talk about the motivation leading to the formation of the IHG, how it has worked thus far and what lessons we can learn that might benefit other FP communities. We will also look at how we can encourage the positive feedback cycle between commercial users and the wider community.</p
      ><hr
       /></div
    ><div id="cufp-discussion"
    ><h2
      ><a href="#TOC"
	>CUFP Discussion</a
	></h2
      ><p
      ><a href="http://www.vimeo.com/6696959"
	>CUFP Discussion</a
	></p
      ><ul
      ><li
	>John Launchbury, <a href="http://galois.com"
	  >Galois, Inc</a
	  ></li
	></ul
      ><p
      >Note taker: <a href="http://donsbot.wordpresss.com"
	>Don Stewart</a
	></p
      ></div
    ></body
  ></html
>

